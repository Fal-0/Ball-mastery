<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Ball Mastery</title>
<style>
  :root{ --bg:#0b0f14; --glass:#10151bAA; --ink:#e7eef7; --pill:#17202a; --accent:#00c8ff }
  *{ box-sizing:border-box }
  body{ margin:0; background:var(--bg); color:var(--ink); font-family:system-ui,Segoe UI,Arial }
  #wrap{ position:fixed; inset:0; background:#000; }
  #view{ width:100vw; height:100vh; display:block; } /* canvas always fills screen; letterbox handled in JS */
  #hud{ position:fixed; left:12px; top:10px; z-index:20; font-weight:600; text-shadow:0 2px 6px #000 }
  .pill{ padding:.3rem .6rem; border-radius:999px; background:var(--pill); color:#cfe1ff; display:inline-block; margin-right:.4rem }
  #ui{ position:fixed; left:0; right:0; bottom:0; background:var(--glass); backdrop-filter:blur(6px);
       padding:10px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; z-index:20 }
  button,select,input[type=range]{ font-size:14px }
  button{ padding:.55rem .8rem; border-radius:10px; border:1px solid #22303a; background:#121920; color:var(--ink) }
  label{ font-size:12px; opacity:.9; display:flex; align-items:center; gap:6px }
  .hint{ position:fixed; right:12px; top:10px; font-size:12px; opacity:.75 }
</style>
</head>
<body>
<div id="wrap">
  <video id="video" playsinline muted style="display:none"></video>
  <canvas id="view"></canvas>
</div>

<div id="hud">
  <span class="pill" id="score">Score: 0</span>
  <span class="pill" id="time">Time: 45s</span>
  <span class="pill" id="modepill">Mode: altLR</span>
</div>
<div class="hint">Tip: add to Home Screen for full screen</div>

<div id="ui">
  <button id="startBtn">Start Camera</button>
  <button id="toggleBtn">Switch Camera</button>
  <button id="roundBtn">Start Round</button>
  <select id="modeSel" aria-label="Mode">
    <option value="altLR">Alternate L/R</option>
    <option value="leftOnly">Left only</option>
    <option value="rightOnly">Right only</option>
    <option value="random">Random</option>
  </select>
  <label>Target <input id="rad" type="range" min="30" max="140" value="80"></label>
  <label>H: <input id="hmin" type="range" min="0" max="360" value="20">
           <input id="hmax" type="range" min="0" max="360" value="50"></label>
  <label>S: <input id="smin" type="range" min="0" max="100" value="55">
           <input id="smax" type="range" min="0" max="100" value="100"></label>
  <label>V: <input id="vmin" type="range" min="0" max="100" value="45">
           <input id="vmax" type="range" min="0" max="100" value="100"></label>
</div>

<script>
/* ----------------- elements ----------------- */
const video = document.getElementById('video');
const view  = document.getElementById('view');
const vctx  = view.getContext('2d', { alpha:false, desynchronized:true });

const startBtn  = document.getElementById('startBtn');
const toggleBtn = document.getElementById('toggleBtn');
const roundBtn  = document.getElementById('roundBtn');
const modeSel   = document.getElementById('modeSel');
const radEl     = document.getElementById('rad');
const hudScore  = document.getElementById('score');
const hudTime   = document.getElementById('time');
const modePill  = document.getElementById('modepill');

const sliders = ["hmin","hmax","smin","smax","vmin","vmax"].reduce((o,id)=> (o[id]=document.getElementById(id),o), {});

/* ----------------- state ----------------- */
let usingFront = false;     // camera side
let mirror     = false;     // draw mirrored for front cam
let running    = false;
let timer      = null;
let timeLeft   = 45;
let score      = 0;
let mode       = "altLR";
let needLeft   = true;
let lastHitAt  = 0;
const debounceMs = 320;

// video/native resolution
let vidW=1280, vidH=720;

// offscreen canvas at native video size for processing
const proc = document.createElement('canvas');
const pctx = proc.getContext('2d', { willReadFrequently:true });

const target = { x:640, y:360, r:80 };
let prevCenter = null;

/* ----------------- helpers ----------------- */
function pick(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function newTarget(obey=true){
  const r = target.r, margin = 40 + r;
  const L = [margin, Math.floor(vidW*0.38)], R = [Math.floor(vidW*0.62), vidW - margin];
  const y = pick(margin, vidH - margin);
  if (!obey || mode==="random") target.x = pick(margin, vidW - margin);
  else if (mode==="altLR"){ target.x = needLeft? pick(...L) : pick(...R); needLeft = !needLeft; }
  else if (mode==="leftOnly"){  target.x = pick(...L); }
  else if (mode==="rightOnly"){ target.x = pick(...R); }
  target.y = y;
}

function rgb2hsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if (d!==0){
    switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;default:h=(r-g)/d+4;}
    h/=6;
  }
  const s = max===0 ? 0 : d/max;
  return [h*360, s*100, max*100];
}
function hsvOK(h,s,v){
  const H=[+sliders.hmin.value,+sliders.hmax.value], S=[+sliders.smin.value,+sliders.smax.value], V=[+sliders.vmin.value,+sliders.vmax.value];
  if (H[0] <= H[1]) return (h>=H[0]&&h<=H[1] && s>=S[0]&&s<=S[1] && v>=V[0]&&v<=V[1]);
  return ((h>=H[0]||h<=H[1]) && s>=S[0]&&s<=S[1] && v>=V[0]&&v<=V[1]);
}

/* ----------------- camera + resize ----------------- */
async function startCamera(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: usingFront ? "user" : "environment",
               width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30,max:60} },
      audio:false
    });
    // stop old stream if any
    if (video.srcObject) video.srcObject.getTracks().forEach(t=>t.stop());
    video.srcObject = stream;
    await video.play();

    // actual native size
    vidW = video.videoWidth || 1280;
    vidH = video.videoHeight || 720;

    // processing canvas uses native size
    proc.width = vidW;
    proc.height = vidH;

    mirror = usingFront; // mirror front camera to behave like a selfie view
    resizeView();        // size the on-screen canvas to the window
    running = true;
    loop();
  }catch(e){
    alert("Camera error: " + e.message);
  }
}

function resizeView(){
  // canvas fills the screen; we compute letterbox params inside draw()
  view.width  = window.innerWidth;
  view.height = window.innerHeight;
}
window.addEventListener('resize', resizeView);
window.addEventListener('orientationchange', () => setTimeout(resizeView, 200));

/* ----------------- detection ----------------- */
function detectCenter(){
  // draw current video frame to processing canvas (mirrored if front cam)
  pctx.save();
  if (mirror){
    pctx.translate(vidW, 0);
    pctx.scale(-1, 1);
  }
  pctx.drawImage(video, 0, 0, vidW, vidH);
  pctx.restore();

  const img = pctx.getImageData(0, 0, vidW, vidH);
  const d = img.data; const step = 4;
  let sx=0, sy=0, c=0;
  for (let y=0; y<vidH; y+=step){
    for (let x=0; x<vidW; x+=step){
      const i=(y*vidW + x)*4;
      const [hh,ss,vv]=rgb2hsv(d[i],d[i+1],d[i+2]);
      if (hsvOK(hh,ss,vv)){ sx+=x; sy+=y; c++; }
    }
  }
  if (c<8) return null;
  let cx=sx/c, cy=sy/c;
  if (prevCenter){ cx = 0.35*cx + 0.65*prevCenter.x; cy = 0.35*cy + 0.65*prevCenter.y; }
  prevCenter = {x:cx, y:cy};
  return prevCenter;
}

/* ----------------- draw (letterboxed) ----------------- */
function drawFrame(center){
  const vw=view.width, vh=view.height;
  const scale = Math.min(vw/vidW, vh/vidH);
  const dw = vidW*scale, dh = vidH*scale;
  const dx = (vw - dw)/2, dy = (vh - dh)/2;

  // draw video frame (from proc canvas so front camera is already mirrored)
  vctx.clearRect(0,0,vw,vh);
  vctx.drawImage(proc, dx, dy, dw, dh);

  // transform helper from native video coords -> screen coords
  const tx = x => dx + x*scale;
  const ty = y => dy + y*scale;

  // HUD
  vctx.fillStyle="#fff"; vctx.font="24px system-ui";
  vctx.fillText(`Score:${score}`, 16, 30);
  vctx.fillText(`Time:${timeLeft}s`, 160, 30);
  vctx.strokeStyle="rgba(0,200,255,0.95)"; vctx.lineWidth=4;
  vctx.beginPath(); vctx.arc(tx(target.x), ty(target.y), target.r*scale, 0, Math.PI*2); vctx.stroke();
  if (center){
    vctx.fillStyle="rgba(0,255,150,0.95)";
    vctx.beginPath(); vctx.arc(tx(center.x), ty(center.y), 7, 0, Math.PI*2); vctx.fill();
  }
}

function hitTest(center){
  if (!center) return;
  const dx = center.x - target.x, dy = center.y - target.y;
  const dist = Math.hypot(dx,dy);
  const now = performance.now();
  if (dist <= target.r*0.95 && (now - lastHitAt) > debounceMs){
    score++; lastHitAt = now; newTarget(true); hudScore.textContent = `Score: ${score}`;
  }
}

function loop(){
  if (!running) return;
  const center = detectCenter();
  hitTest(center);
  drawFrame(center);
  requestAnimationFrame(loop);
}

/* ----------------- rounds & UI ----------------- */
function startRound(){
  score=0; timeLeft=45;
  hudScore.textContent="Score: 0"; hudTime.textContent="Time: 45s";
  target.r=+radEl.value; mode=modeSel.value; modePill.textContent=`Mode: ${mode}`;
  needLeft=true; newTarget(true);
  if (!running) startCamera();
  if (timer) clearInterval(timer);
  timer = setInterval(()=>{
    timeLeft--; hudTime.textContent=`Time: ${timeLeft}s`;
    if (timeLeft<=0){ clearInterval(timer); timer=null; alert(`Round complete! Score: ${score}`); }
  },1000);
}

startBtn.onclick  = ()=> { if(!running){ resizeView(); startCamera(); } };
toggleBtn.onclick = ()=> { usingFront = !usingFront; startCamera(); };
roundBtn.onclick  = startRound;
modeSel.onchange  = ()=> (mode = modeSel.value, modePill.textContent=`Mode: ${mode}`, newTarget(true));
radEl.oninput     = ()=> (target.r = +radEl.value);
</script>
</body>
</html>
